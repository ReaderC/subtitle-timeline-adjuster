<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>字幕时间轴调整工具</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    :root {
        --bs-body-font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        --bs-body-bg: #f0f2f5;
    }
    html, body { height: 100%; }
    .main-container { display: flex; flex-direction: column; height: 100vh; }
    .main-row { flex-grow: 1; overflow-y: auto; }
    .panel { display: flex; flex-direction: column; height: 100%; }
    .card-body-scroll { overflow-y: auto; flex: 1; }
    .file-list { list-style: none; padding-left: 0; }
    .file-list-item { display: flex; justify-content: space-between; align-items: center; padding: .4rem .8rem; border: 1px solid #ddd; border-radius: .25rem; margin-bottom: .25rem; cursor: pointer; transition: background-color .2s; }
    .file-list-item:hover { background-color: #f5f5f5; }
    .file-list-item.active { background-color: var(--bs-primary); color: white; border-color: var(--bs-primary); }
    .file-list-item .file-name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .file-list-item .file-source { font-size: .8em; }
    .file-list-item.active .file-source { color: white; }
    .video-wrapper { position: relative; width: 100%; background-color: #000; }
    #videoPlayer { width: 100%; height: auto; max-height: 60vh; }
    #subtitleDisplay { position: absolute; bottom: 10%; left: 50%; transform: translateX(-50%); background-color: rgba(0,0,0,0.7); color: white; padding: 5px 15px; border-radius: 5px; text-align: center; width: 90%; min-height: 50px; display: flex; justify-content: center; align-items: center; cursor: pointer; transition: background-color .2s; }
    #subtitleDisplay:hover { background-color: rgba(0,0,0,0.85); }
    #editor-resizer { height: 10px; background-color: #e0e0e0; cursor: ns-resize; }
    .editor-wrapper { display: none; /* Initially hidden */ flex-direction: column; }
    .editor-wrapper.active { display: flex; }
    #subtitle-editor { font-family: monospace; font-size: 0.9em; }
    .editor-row { display: flex; align-items: center; border-bottom: 1px solid #f0f0f0; padding: 2px; }
    .editor-row > * { padding: 2px 4px; }
    .editor-index { flex-basis: 40px; flex-shrink: 0; }
    .editor-time-group { flex-basis: 150px; flex-shrink: 0; display: flex; align-items: center; }
    .editor-text { flex-grow: 1; }
    .editor-row input[type="text"] { width: 80px; border: 1px solid #ddd; padding: 2px; font-size: 0.9em; }
    .active-editor-row { background-color: #e0ffe0; }
    .file-browser .file-item { padding: 5px; cursor: pointer; }
    .file-browser .file-item:hover { background-color: #f0f0f0; }
  </style>
</head>
<body>
  <div class="main-container p-2">
    <header class="pb-2">
      <h1 class="h4">字幕时间轴调整工具</h1>
    </header>

    <div class="row g-2 main-row">
      <!-- Left Panel -->
      <div class="col-lg-4">
        <div class="panel">
          <div class="card mb-2">
            <div class="card-header">
              <h2 class="h6 mb-0">
                <a data-bs-toggle="collapse" href="#serverSettingsCollapse" role="button" aria-expanded="false" aria-controls="serverSettingsCollapse" class="text-decoration-none">
                  服务器设置 (可选)
                </a>
              </h2>
            </div>
            <div class="collapse" id="serverSettingsCollapse">
              <div class="card-body">
                <div class="input-group">
                  <span class="input-group-text">Token</span>
                  <input type="password" id="serverTokenInput" class="form-control" placeholder="如果服务器设置了 Token">
                </div>
              </div>
            </div>
          </div>

          <div class="card flex-grow-1">
            <div class="card-header d-flex justify-content-between align-items-center">
              <h2 class="h6 mb-0">媒体文件</h2>
              <button class="btn btn-primary btn-sm" onclick="openAddFileModal()">添加文件</button>
            </div>
            <div class="card-body d-flex flex-column p-2">
              <nav>
                <div class="nav nav-tabs" id="nav-tab" role="tablist">
                  <button class="nav-link active" id="nav-video-tab" data-bs-toggle="tab" data-bs-target="#nav-video" type="button" role="tab">视频</button>
                  <button class="nav-link" id="nav-subtitle-tab" data-bs-toggle="tab" data-bs-target="#nav-subtitle" type="button" role="tab">字幕</button>
                </div>
              </nav>
              <div class="tab-content flex-grow-1" id="nav-tabContent">
                <div class="tab-pane fade show active pt-2" id="nav-video" role="tabpanel">
                  <div class="d-flex justify-content-end mb-1"><button class="btn btn-danger btn-sm" onclick="clearFileList('video')">清空</button></div>
                  <div id="videoList" class="file-list card-body-scroll file-drop-area"></div>
                </div>
                <div class="tab-pane fade pt-2" id="nav-subtitle" role="tabpanel">
                  <div class="d-flex justify-content-end mb-1"><button class="btn btn-danger btn-sm" onclick="clearFileList('subtitle')">清空</button></div>
                  <div id="subtitleList" class="file-list card-body-scroll file-drop-area"></div>
                </div>
              </div>
              <div id="status" class="mt-2 text-muted small"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- Right Panel -->
      <div class="col-lg-8">
        <div class="panel">
          <div class="card flex-grow-1">
            <div class="card-header"><h2 class="h6 mb-0">预览和处理</h2></div>
            <div class="card-body d-flex flex-column">
              <div class="row g-2 mb-2">
                <div class="col-md-6">
                  <div class="card">
                    <div class="card-body">
                      <h6 class="card-title">播放器控制</h6>
                      <div class="d-flex flex-wrap gap-2">
                        <div class="input-group input-group-sm" style="width: 150px;">
                          <label class="input-group-text" for="playbackRateInput">速度</label>
                          <input type="number" id="playbackRateInput" class="form-control" min="0.1" max="4" step="0.1" value="1.0" onchange="setPlaybackRate()">
                        </div>
                        <div class="btn-group btn-group-sm">
                          <button class="btn btn-outline-secondary" onclick="setSpeed(0.5)">0.5x</button>
                          <button class="btn btn-outline-secondary" onclick="setSpeed(1.0)">1.0x</button>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
                <div class="col-md-6">
                  <div class="card">
                    <div class="card-body">
                      <h6 class="card-title">字幕时间轴批量调整</h6>
                      <div class="d-flex flex-wrap gap-2">
                        <div class="input-group input-group-sm" style="width: 200px;">
                          <input type="number" id="customAdjustMs" class="form-control" value="100" placeholder="输入毫秒数">
                          <button class="btn btn-secondary" onclick="customStepAdjust(true)">延迟</button>
                          <button class="btn btn-secondary" onclick="customStepAdjust(false)">提前</button>
                        </div>
                        <div class="btn-group btn-group-sm">
                            <button class="btn btn-outline-secondary" onclick="stepAdjust(50, true)">延迟 50ms</button>
                            <button class="btn btn-outline-secondary" onclick="stepAdjust(-50, true)">提前 50ms</button>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
              <div class="mb-2">
                <button class="btn btn-success" onclick="loadFilesToPlayer()">加载/重置预览</button>
                <button class="btn btn-warning" onclick="loadSubtitleForEditing()">单独编辑字幕</button>
                <button class="btn btn-info" onclick="saveAdjustedSubtitle()">保存字幕</button>
              </div>
              <div class="video-wrapper mb-2">
                <video id="videoPlayer" controls></video>
                <div id="subtitleDisplay"></div>
              </div>
              
              <div id="editor-resizer" class="resizer"></div>
              
              <div class="editor-wrapper flex-grow-1" id="editorWrapper">
                <div class="d-flex justify-content-between align-items-center p-1 bg-light border-bottom">
                  <h3 id="editor-title" class="h6 mb-0">字幕编辑器</h3>
                  <div>
                    <button class="btn btn-sm btn-primary" onclick="addSubtitle()">增加字幕</button>
                    <button id="closeEditorBtn" type="button" class="btn-close" aria-label="Close"></button>
                  </div>
                </div>
                <div id="subtitle-editor" class="card-body-scroll"></div>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Add File Modal -->
  <div class="modal fade" id="addFileModal" tabindex="-1">
    <div class="modal-dialog modal-lg">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="modalTitle">添加文件</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
        </div>
        <div class="modal-body" id="modalSourceSelection">
          <div class="d-grid gap-2">
            <button onclick="dom.fileUploader.click()" class="btn btn-primary btn-lg">从本地上传</button>
            <input type="file" id="fileUploader" style="display:none;" multiple/>
            <button id="browseServerBtn" onclick="showServerBrowser()" class="btn btn-secondary btn-lg" disabled>从服务器浏览</button>
          </div>
        </div>
        <div class="modal-body" id="modalServerBrowser" style="display:none;">
          <div class="d-flex justify-content-between align-items-center mb-2">
            <span id="current-path" class="text-muted">/</span>
            <button class="btn btn-sm btn-outline-secondary" onclick="browseDirectory('')">返回根目录</button>
          </div>
          <div id="fileBrowser" class="file-browser border rounded p-2" style="min-height: 200px;"></div>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>

  <script>
    // --- State & DOM Elements ---
    let videoList = [], subtitleList = [], activeVideo = null, activeSubtitle = null, originalSubtitleData = null, activeSubtitleData = null;
    let addFileModal; // Bootstrap Modal instance

    const dom = {
        videoPlayer: document.getElementById('videoPlayer'),
        statusEl: document.getElementById('status'),
        modalEl: document.getElementById('addFileModal'),
        modalTitle: document.getElementById('modalTitle'),
        modalSourceSelection: document.getElementById('modalSourceSelection'),
        modalServerBrowser: document.getElementById('modalServerBrowser'),
        fileUploader: document.getElementById('fileUploader'),
        fileBrowserEl: document.getElementById('fileBrowser'),
        currentPathEl: document.getElementById('current-path'),
        browseServerBtn: document.getElementById('browseServerBtn'),
        serverTokenInput: document.getElementById('serverTokenInput'),
        playbackRateInput: document.getElementById('playbackRateInput'),
        subtitleEditor: document.getElementById('subtitle-editor'),
        editorTitle: document.getElementById('editor-title'),
        editorResizer: document.getElementById('editor-resizer'),
        editorWrapper: document.getElementById('editorWrapper'),
        playerWrapper: document.querySelector('.player-wrapper'), // Note: This class is not in the new HTML, might need adjustment if used
        rightPanel: document.querySelector('.col-lg-8 .panel'),
        subtitleDisplay: document.getElementById('subtitleDisplay'),
        closeEditorBtn: document.getElementById('closeEditorBtn')
    };

    // --- Modal & File Addition Logic ---
    function openAddFileModal() { addFileModal.show(); dom.modalSourceSelection.style.display = 'block'; dom.modalServerBrowser.style.display = 'none'; }
    function closeModal() { addFileModal.hide(); }
    function showServerBrowser() { dom.modalSourceSelection.style.display = 'none'; dom.modalServerBrowser.style.display = 'block'; browseDirectory(); }
    dom.fileUploader.onchange = (e) => { addFiles(e.target.files, 'local'); };

    function addFiles(files, source, pathPrefix = '') {
        for (const file of files) {
            const fileType = file.type.startsWith('video/') || file.name.match(/\.(mp4|mkv|webm|mov)$/i) ? 'video' : (file.name.match(/\.(srt|ass)$/i) ? 'subtitle' : null);
            if (!fileType) continue;
            const targetList = fileType === 'video' ? videoList : subtitleList;
            const newItem = source === 'local' ? { source, file, name: file.name } : { source, path: pathPrefix ? `${pathPrefix}/${file.name}` : file.name, name: file.name };
            if (!targetList.some(item => item.name === newItem.name)) targetList.push(newItem);
        }
        renderFileList('video');
        renderFileList('subtitle');
        closeModal();
    }

    // --- Drag and Drop Logic ---
    function setupDragDrop() {
        const dropArea = document.querySelector('.card-body .tab-content').parentElement;
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropArea.addEventListener(eventName, e => { e.preventDefault(); e.stopPropagation(); }, false);
        });
        
        let dragCounter = 0;

        dropArea.addEventListener('dragenter', (e) => {
            dragCounter++;
            // Apply visual feedback only on the first enter
            if (dragCounter === 1) {
                dropArea.style.border = '2px dashed #0d6efd';
                dropArea.style.backgroundColor = '#f0f8ff';
            }
        });

        dropArea.addEventListener('dragleave', (e) => {
            dragCounter--;
            // Remove visual feedback only when leaving the drop area completely
            if (dragCounter === 0) {
                dropArea.style.border = '';
                dropArea.style.backgroundColor = '';
            }
        });

        dropArea.addEventListener('drop', e => {
            dragCounter = 0;
            dropArea.style.border = '';
            dropArea.style.backgroundColor = '';
            addFiles(e.dataTransfer.files, 'local');
        });
    }

    // --- Server Browser Logic ---
    async function browseDirectory(path = '') {
        try {
            const response = await fetch(`/api/browse?path=${encodeURIComponent(path)}`, { headers: { 'X-Server-Token': dom.serverTokenInput.value } });
            if (!response.ok) throw new Error(`服务器错误: ${response.statusText}`);
            const data = await response.json();
            dom.currentPathEl.textContent = `/${data.path}`;
            renderServerBrowser(data.path, data.files);
        } catch (error) { dom.fileBrowserEl.innerHTML = `<p class="text-danger">无法加载目录: ${error.message}</p>`; }
    }

    function renderServerBrowser(currentServerPath, files) {
        dom.fileBrowserEl.innerHTML = '';
        if (currentServerPath) {
            const parentPath = currentServerPath.substring(0, currentServerPath.lastIndexOf('/'));
            const upEl = document.createElement('div');
            upEl.className = 'file-item';
            upEl.textContent = '⬆️ [返回上级]';
            upEl.onclick = () => browseDirectory(parentPath);
            dom.fileBrowserEl.appendChild(upEl);
        }
        files.forEach(file => {
            const itemEl = document.createElement('div');
            itemEl.className = 'file-item';
            itemEl.textContent = `${file.type === 'directory' ? '📁' : '📄'} ${file.name}`;
            if (file.type === 'directory') {
                itemEl.onclick = () => browseDirectory(currentServerPath ? `${currentServerPath}/${file.name}` : file.name);
            } else {
                itemEl.onclick = () => addFiles([file], 'server', currentServerPath);
            }
            dom.fileBrowserEl.appendChild(itemEl);
        });
    }

    // --- File List Management ---
    function clearFileList(type) {
        const list = type === 'video' ? videoList : subtitleList;
        if (list.length > 0 && confirm(`确定要清空${type === 'video' ? '视频' : '字幕'}列表吗？`)) {
            if (type === 'video') { videoList = []; activeVideo = null; }
            else { subtitleList = []; activeSubtitle = null; }
            renderFileList(type);
            updateStatus();
        }
    }

    function renderFileList(type) {
        const listId = type === 'video' ? 'videoList' : 'subtitleList';
        const list = type === 'video' ? videoList : subtitleList;
        const listEl = document.getElementById(listId);
        listEl.innerHTML = '';
        list.forEach((item, index) => {
            const itemEl = document.createElement('div');
            itemEl.className = 'file-list-item';
            if ((type === 'video' && item === activeVideo) || (type === 'subtitle' && item === activeSubtitle)) itemEl.classList.add('active');
            
            const nameSpan = document.createElement('span');
            nameSpan.className = 'file-name';
            nameSpan.textContent = item.name;
            
            const sourceSpan = document.createElement('span');
            sourceSpan.className = 'badge bg-secondary file-source';
            sourceSpan.textContent = item.source;

            itemEl.appendChild(nameSpan);
            itemEl.appendChild(sourceSpan);
            
            itemEl.onclick = () => {
                if (type === 'video') activeVideo = item; else activeSubtitle = item;
                renderFileList('video');
                renderFileList('subtitle');
                updateStatus();
            };
            listEl.appendChild(itemEl);
        });
    }

    function updateStatus() {
        dom.statusEl.innerHTML = `<b>当前:</b> 视频 - <i>${activeVideo ? activeVideo.name : 'N/A'}</i> | 字幕 - <i>${activeSubtitle ? activeSubtitle.name : 'N/A'}</i>`;
    }

    // --- Player and Adjustment Actions ---
    async function loadFilesToPlayer() {
        if (!activeVideo) return alert('请在列表中选择一个视频文件');
        dom.videoPlayer.src = activeVideo.source === 'local' ? URL.createObjectURL(activeVideo.file) : `/api/stream?path=${encodeURIComponent(activeVideo.path)}&token=${dom.serverTokenInput.value}`;
        originalSubtitleData = activeSubtitleData = null;
        dom.subtitleEditor.innerHTML = '';
        dom.editorTitle.textContent = '字幕编辑器 (请先加载字幕)';
        closeEditor();
        if (activeSubtitle) {
            try {
                let text = activeSubtitle.source === 'local' ? await activeSubtitle.file.text() : await (await fetch(`/api/subtitle?path=${encodeURIComponent(activeSubtitle.path)}`, { headers: { 'X-Server-Token': dom.serverTokenInput.value } })).text();
                const parsedData = parseSubtitle(text, activeSubtitle.name);

                // Sort subtitles by start time to ensure correct order
                const isSrt = activeSubtitle.name.endsWith('.srt');
                parsedData.sort((a, b) => {
                    const timeA = isSrt ? srtTimeToSeconds(a.startTime) : timeToSeconds(a.startTime);
                    const timeB = isSrt ? srtTimeToSeconds(b.startTime) : timeToSeconds(b.startTime);
                    return timeA - timeB;
                });

                originalSubtitleData = JSON.parse(JSON.stringify(parsedData));
                activeSubtitleData = JSON.parse(JSON.stringify(parsedData));
                renderSubtitleEditor();
                showEditor();
            } catch (e) { alert(`加载字幕失败: ${e.message}`); }
        }
        displaySubtitle(true);
    }

    async function loadSubtitleForEditing() {
        if (!activeSubtitle) return alert('请在列表中选择一个字幕文件');
        originalSubtitleData = activeSubtitleData = null;
        dom.subtitleEditor.innerHTML = '';
        dom.editorTitle.textContent = '字幕编辑器 (请先加载字幕)';
        closeEditor();
        try {
            let text = activeSubtitle.source === 'local' ? await activeSubtitle.file.text() : await (await fetch(`/api/subtitle?path=${encodeURIComponent(activeSubtitle.path)}`, { headers: { 'X-Server-Token': dom.serverTokenInput.value } })).text();
            const parsedData = parseSubtitle(text, activeSubtitle.name);

            // Sort subtitles by start time to ensure correct order
            const isSrt = activeSubtitle.name.endsWith('.srt');
            parsedData.sort((a, b) => {
                const timeA = isSrt ? srtTimeToSeconds(a.startTime) : timeToSeconds(a.startTime);
                const timeB = isSrt ? srtTimeToSeconds(b.startTime) : timeToSeconds(b.startTime);
                return timeA - timeB;
            });

            originalSubtitleData = JSON.parse(JSON.stringify(parsedData));
            activeSubtitleData = JSON.parse(JSON.stringify(parsedData));
            renderSubtitleEditor();
            showEditor();
        } catch (e) { alert(`加载字幕失败: ${e.message}`); }
    }

    async function saveAdjustedSubtitle() {
        if (!activeSubtitle || !activeSubtitleData) return alert('没有可保存的字幕');
        try {
            let fileContent;
            if (activeSubtitle.name.endsWith('.srt')) {
                fileContent = stringifySrt(activeSubtitleData);
            } else {
                const originalText = activeSubtitle.source === 'local' ? await activeSubtitle.file.text() : await (await fetch(`/api/subtitle?path=${encodeURIComponent(activeSubtitle.path)}`, { headers: { 'X-Server-Token': dom.serverTokenInput.value } })).text();
                fileContent = stringifyAss(originalText, activeSubtitleData);
            }
            dom.statusEl.textContent = '正在后台保存...';
            const res = await fetch(`/api/save?filename=${encodeURIComponent(activeSubtitle.name)}`, { method: 'POST', headers: { 'Content-Type': 'text/plain' }, body: fileContent });
            const data = await res.json();
            dom.statusEl.innerHTML = data.error ? `保存失败: ${data.error}` : `保存成功! <a href="${data.downloadLink}" download>点击下载</a>`;
        } catch (e) { dom.statusEl.textContent = `保存失败: ${e.message}`; }
    }

    // --- Editor and Time Logic ---
    function addSubtitle() {
        if (!activeSubtitleData) return;

        const isSrt = activeSubtitle.name.endsWith('.srt');
        let currentTime = 0;
        // Use video current time if available, otherwise find a sensible default
        if (dom.videoPlayer.src && !dom.videoPlayer.paused) {
            currentTime = dom.videoPlayer.currentTime;
        } else if (activeSubtitleData.length > 0) {
            // If no video, insert after the last subtitle
            const lastTime = activeSubtitleData[activeSubtitleData.length - 1].endTime;
            currentTime = (isSrt ? srtTimeToSeconds(lastTime) : timeToSeconds(lastTime)) + 0.1;
        }

        // Find the correct index to insert the new subtitle
        let insertIndex = activeSubtitleData.findIndex(line => {
            const startTime = isSrt ? srtTimeToSeconds(line.startTime) : timeToSeconds(line.startTime);
            return startTime > currentTime;
        });

        if (insertIndex === -1) {
            insertIndex = activeSubtitleData.length;
        }

        // Determine the new ID
        let newId = 1;
        if (isSrt) {
            if (insertIndex > 0) {
                newId = parseInt(activeSubtitleData[insertIndex - 1].id, 10) + 1;
            } else {
                newId = 1;
            }
        }

        const newSubtitle = {
            id: isSrt ? newId.toString() : null, // ID is specific to SRT
            startTime: isSrt ? secondsToSrtTime(currentTime) : secondsToTime(currentTime),
            endTime: isSrt ? secondsToSrtTime(currentTime + 2) : secondsToTime(currentTime + 2),
            text: '[新字幕]'
        };

        // Insert the new subtitle
        activeSubtitleData.splice(insertIndex, 0, newSubtitle);

        // If it's an SRT file, re-sequence all subsequent subtitle IDs
        if (isSrt) {
            for (let i = insertIndex + 1; i < activeSubtitleData.length; i++) {
                activeSubtitleData[i].id = (parseInt(activeSubtitleData[i-1].id, 10) + 1).toString();
            }
        }

        renderSubtitleEditor();
        displaySubtitle(true);
        jumpToEditorLine(insertIndex);
    }

    function deleteSubtitle(index) {
        if (confirm('确定要删除这条字幕吗？')) {
            activeSubtitleData.splice(index, 1);
            renderSubtitleEditor();
        }
    }

    function updateLineText(index, newText) {
        activeSubtitleData[index].text = newText;
        displaySubtitle(true);
    }

    function renderSubtitleEditor() {
        dom.subtitleEditor.innerHTML = '';
        dom.editorTitle.textContent = `正在编辑: ${activeSubtitle.name}`;
        activeSubtitleData.forEach((line, index) => {
            const row = document.createElement('div');
            row.className = 'editor-row';
            row.dataset.index = index;
            row.innerHTML = `
                <div class="editor-index">${line.id || index + 1}</div>
                <div class="editor-time-group">
                    <button class="btn btn-sm btn-outline-secondary time-adj-btn" onclick="adjustLineTime(${index}, 'startTime', -0.05)">-</button>
                    <input type="text" id="startTime-${index}" value="${line.startTime}" onchange="updateLineTime(${index}, 'startTime', this.value)">
                    <button class="btn btn-sm btn-outline-secondary time-adj-btn" onclick="adjustLineTime(${index}, 'startTime', 0.05)">+</button>
                </div>
                <div class="editor-time-group">
                    <button class="btn btn-sm btn-outline-secondary time-adj-btn" onclick="adjustLineTime(${index}, 'endTime', -0.05)">-</button>
                    <input type="text" id="endTime-${index}" value="${line.endTime}" onchange="updateLineTime(${index}, 'endTime', this.value)">
                    <button class="btn btn-sm btn-outline-secondary time-adj-btn" onclick="adjustLineTime(${index}, 'endTime', 0.05)">+</button>
                </div>
                <div class="editor-text" contenteditable="true" onblur="updateLineText(${index}, this.innerText)">${line.text}</div>
                <button class="btn btn-sm btn-danger" onclick="deleteSubtitle(${index})">删除</button>
            `;
            dom.subtitleEditor.appendChild(row);
        });
    }

    function updateLineTime(index, part, value) {
        const isSrt = activeSubtitle.name.endsWith('.srt');
        let timeInSeconds = isSrt ? srtTimeToSeconds(value) : timeToSeconds(value);
        if (isNaN(timeInSeconds)) {
            alert('时间格式无效');
            // Re-render to restore the original value if input is invalid
            const originalTime = activeSubtitleData[index][part];
            document.getElementById(`${part}-${index}`).value = originalTime;
            return;
        }
        activeSubtitleData[index][part] = isSrt ? secondsToSrtTime(timeInSeconds) : secondsToTime(timeInSeconds);
        displaySubtitle(true);
    }

    function adjustLineTime(index, part, amountInSeconds) {
        const isSrt = activeSubtitle.name.endsWith('.srt');
        const originalTime = activeSubtitleData[index][part];
        let timeInSeconds = isSrt ? srtTimeToSeconds(originalTime) : timeToSeconds(originalTime);
        
        timeInSeconds += amountInSeconds;
        if (timeInSeconds < 0) timeInSeconds = 0;

        const newTime = isSrt ? secondsToSrtTime(timeInSeconds) : secondsToTime(timeInSeconds);
        activeSubtitleData[index][part] = newTime;
        
        // Directly update the input field value
        const inputElement = document.getElementById(`${part}-${index}`);
        if (inputElement) {
            inputElement.value = newTime;
        }
        
        displaySubtitle(true);
    }
    
    function customStepAdjust(isDelay) {
        const msInput = document.getElementById('customAdjustMs');
        let amountInMs = parseInt(msInput.value, 10);
        if (isNaN(amountInMs)) {
            return alert('请输入有效的毫秒数');
        }
        if (!isDelay) {
            amountInMs = -amountInMs;
        }
        stepAdjust(amountInMs, true);
    }

    function stepAdjust(amountInMs, isGlobal) {
        if (!activeSubtitleData) return alert('请先加载字幕');
        const amountInSeconds = amountInMs / 1000;
        const isSrt = activeSubtitle.name.endsWith('.srt');
        activeSubtitleData.forEach(line => {
            let start = isSrt ? srtTimeToSeconds(line.startTime) : timeToSeconds(line.startTime);
            let end = isSrt ? srtTimeToSeconds(line.endTime) : timeToSeconds(line.endTime);
            start += amountInSeconds; end += amountInSeconds;
            line.startTime = isSrt ? secondsToSrtTime(start) : secondsToTime(start);
            line.endTime = isSrt ? secondsToSrtTime(end) : secondsToTime(end);
        });
        renderSubtitleEditor();
        displaySubtitle(true);
    }

    // --- Stringify and Time Conversion ---
    function stringifySrt(data) { return data.map(line => `${line.id}\n${line.startTime} --> ${line.endTime}\n${line.text}`).join('\n\n') + '\n\n'; }
    function stringifyAss(originalContent, data) {
        let eventIndex = 0;
        return originalContent.split('\n').map(line => {
            if (line.startsWith('Dialogue:') || line.startsWith('Comment:')) {
                if (eventIndex < data.length) {
                    const parts = line.split(',');
                    parts[1] = data[eventIndex].startTime;
                    parts[2] = data[eventIndex].endTime;
                    eventIndex++;
                    return parts.join(',');
                }
            }
            return line;
        }).join('\n');
    }
    function secondsToSrtTime(s){const h=Math.floor(s/3600);s%=3600;const m=Math.floor(s/60);s%=60;const c=Math.floor(s);const f=Math.round((s-c)*1000);return`${String(h).padStart(2,'0')}:${String(m).padStart(2,'0')}:${String(c).padStart(2,'0')},${String(f).padStart(3,'0')}`}
    function srtTimeToSeconds(t){const p=t.split(/[:,]/);return 3600*parseInt(p[0],10)+60*parseInt(p[1],10)+parseInt(p[2],10)+parseInt(p[3],10)/1000}
    function timeToSeconds(t){const p=t.split(':');return 3600*parseInt(p[0],10)+60*parseInt(p[1],10)+parseFloat(p[2])}
    function secondsToTime(s){if(s<0)s=0;const h=Math.floor(s/3600);s%=3600;const m=Math.floor(s/60);s%=60;const c=Math.floor(s);const f=Math.round((s-c)*100);return`${h}:${String(m).padStart(2,'0')}:${String(c).padStart(2,'0')}.${String(f).padStart(2,'0')}`}
    function setPlaybackRate() { dom.videoPlayer.playbackRate = parseFloat(dom.playbackRateInput.value) || 1; }
    function setSpeed(rate) { dom.playbackRateInput.value = rate; setPlaybackRate(); }
    
    let animationFrameId = null, currentDisplayedSubtitleIndex = -1;
    function displaySubtitle(forceUpdate = false) {
      if (!forceUpdate && animationFrameId) cancelAnimationFrame(animationFrameId);
      const currentTime = dom.videoPlayer.currentTime;
      let currentSubtitle = '';
      currentDisplayedSubtitleIndex = -1;
      if (activeSubtitleData) {
        const isSrt = activeSubtitle.name.endsWith('.srt');
        for (let i = 0; i < activeSubtitleData.length; i++) {
          const subtitle = activeSubtitleData[i];
          const startInSeconds = isSrt ? srtTimeToSeconds(subtitle.startTime) : timeToSeconds(subtitle.startTime);
          const endInSeconds = isSrt ? srtTimeToSeconds(subtitle.endTime) : timeToSeconds(subtitle.endTime);
          if (currentTime >= startInSeconds && currentTime <= endInSeconds) {
            currentSubtitle = subtitle.text;
            currentDisplayedSubtitleIndex = i;
            break;
          }
        }
      }
      dom.subtitleDisplay.textContent = currentSubtitle;
      
      // Highlight editor line
      const prevActive = dom.subtitleEditor.querySelector('.active-editor-row');
      if (prevActive) prevActive.classList.remove('active-editor-row');
      if (currentDisplayedSubtitleIndex !== -1) {
        const targetRow = dom.subtitleEditor.querySelector(`[data-index="${currentDisplayedSubtitleIndex}"]`);
        if (targetRow) targetRow.classList.add('active-editor-row');
      }

      if (!dom.videoPlayer.paused) animationFrameId = requestAnimationFrame(() => displaySubtitle(false));
    }
    dom.videoPlayer.addEventListener('play', () => displaySubtitle(false));
    dom.videoPlayer.addEventListener('seeking', () => displaySubtitle(true));
    dom.videoPlayer.addEventListener('pause', () => cancelAnimationFrame(animationFrameId));

    // --- Editor Jump & Visibility Logic ---
    function showEditor() {
        dom.editorWrapper.classList.add('active');
        dom.editorWrapper.style.height = '200px'; // Initial height
    }

    function jumpToEditorLine(index) {
        if (index < 0 || !activeSubtitleData || index >= activeSubtitleData.length) return;
        showEditor();
        const targetRow = dom.subtitleEditor.querySelector(`[data-index="${index}"]`);
        if (targetRow) {
            targetRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }

    dom.subtitleDisplay.addEventListener('click', () => {
        if (currentDisplayedSubtitleIndex !== -1) {
            jumpToEditorLine(currentDisplayedSubtitleIndex);
            dom.videoPlayer.pause();
        }
    });

    function closeEditor() {
        dom.editorWrapper.classList.remove('active');
        dom.editorWrapper.style.height = '0';
        const prevActive = dom.subtitleEditor.querySelector('.active-editor-row');
        if (prevActive) prevActive.classList.remove('active-editor-row');
    }

    dom.closeEditorBtn.addEventListener('click', closeEditor);

    // --- Resizer Logic ---
    function setupResizer() {
        let isResizing = false;
        dom.editorResizer.addEventListener('mousedown', (e) => {
            isResizing = true;
            document.body.style.userSelect = 'none';
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        });

        function onMouseMove(e) {
            if (!isResizing) return;
            const rightPanelRect = dom.rightPanel.getBoundingClientRect();
            const newHeight = rightPanelRect.bottom - e.clientY - dom.editorResizer.offsetHeight;
            const minHeight = 50;
            const maxHeight = rightPanelRect.height - 200; // Keep player visible
            if (newHeight > minHeight && newHeight < maxHeight) {
                dom.editorWrapper.style.height = `${newHeight}px`;
            }
        }

        function onMouseUp() {
            isResizing = false;
            document.body.style.userSelect = '';
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        }
    }

    // --- Initial Load ---
    document.addEventListener('DOMContentLoaded', async () => {
        addFileModal = new bootstrap.Modal(dom.modalEl);
        try {
            const response = await fetch('/api/status');
            const data = await response.json();
            if (data.isServerFsEnabled) {
                dom.browseServerBtn.disabled = false;
                dom.browseServerBtn.title = '浏览服务器上的文件';
            } else {
                dom.browseServerBtn.title = '服务器未配置媒体目录';
            }
        } catch (e) { dom.browseServerBtn.title = '无法连接到服务器'; }
        setupDragDrop();
        updateStatus();
        setupResizer();
    });

    // --- PARSING LOGIC ---
    function parseSubtitle(content, fileName) {
        if (fileName.endsWith('.ass') || fileName.endsWith('.ssa')) return parseASSSubtitle(content); 
        if (fileName.endsWith('.srt')) return parseSRTSubtitle(content);
        return [];
    }

    function parseASSSubtitle(content) {
        const subtitles = [];
        let isInEvents = false;
        const lines = content.split('\n');
        for (const line of lines) {
            const trimmedLine = line.trim();
            if (trimmedLine.startsWith('[Events]')) { isInEvents = true; continue; }
            if (isInEvents && trimmedLine.startsWith('[')) break;
            if (isInEvents && trimmedLine.startsWith('Dialogue:')) {
                const parts = trimmedLine.split(',');
                if (parts.length >= 10) {
                    subtitles.push({
                        startTime: parts[1],
                        endTime: parts[2],
                        text: parts.slice(9).join(',').replace(/\\N/g, '\n').replace(/\{.*?\}/g, '')
                    });
                }
            }
        }
        return subtitles;
    }

    function parseSRTSubtitle(content) {
        return content.split('\n\n').map(block => {
            const lines = block.trim().split('\n');
            if (lines.length >= 2) {
                const timeParts = lines[1].split(' --> ');
                if (timeParts.length === 2) {
                    return {
                        id: lines[0],
                        startTime: timeParts[0],
                        endTime: timeParts[1],
                        text: lines.slice(2).join('\n')
                    };
                }
            }
            return null;
        }).filter(Boolean);
    }
  </script>
</body>
</html>